//
//  StructsTests.swift
//  HactoolSwiftTests
//
//  Created by kila on 2025/6/29.
//

import Testing
import Foundation

// MARK: - 替换你的项目名
@testable import HactoolSwift

// MARK: - 1. HFS0Header
@Suite("HFS0Header Parsing Tests")
struct HFS0HeaderTests {
    @Test("Should correctly parse a valid HFS0 header")
    func testHFS0HeaderParsing() throws {
        // --- ARRANGE ---
        // TODO: 替换为从已知文件中提取的真实二进制数据
        let mockData = Data([
            0x48, 0x46, 0x53, 0x30, 0x0A, 0x00, 0x00, 0x00,
            0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ])
        let expected = HFS0Header(magic: 0x30534648, numFiles: 10, stringTableSize: 384, reserved: 0)
        
        // --- ACT ---
        let parsed = try HFS0Header.parse(from: mockData.withUnsafeBytes { $0 })
        
        // --- ASSERT ---
        #expect(parsed == expected)
    }
}

// MARK: - 2. PFS0Header
@Suite("PFS0Header Parsing Tests")
struct PFS0HeaderTests {
    @Test("Should correctly parse a valid PFS0 header")
    func testPFS0HeaderParsing() throws {
        // --- ARRANGE ---
        // TODO: 替换为从已知文件中提取的真实二进制数据
        let mockData = Data([
            0x50, 0x46, 0x53, 0x30, 0x04, 0x00, 0x00, 0x00,
            0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ])
        let expected = PFS0Header(magic: 0x30534650, numFiles: 4, stringTableSize: 96, reserved: 0)
        
        // --- ACT ---
        let parsed = try PFS0Header.parse(from: mockData.withUnsafeBytes { $0 })
        
        // --- ASSERT ---
        #expect(parsed == expected)
    }
}

// MARK: - 3. INI1Header
@Suite("INI1Header Parsing Tests")
struct INI1HeaderTests {
    @Test("Should correctly parse a valid INI1 header")
    func testINI1HeaderParsing() throws {
        // --- ARRANGE ---
        // TODO: 替换为从已知文件中提取的真实二进制数据
        let mockData = Data([
            0x49, 0x4E, 0x49, 0x31, 0x00, 0x80, 0x0C, 0x00,
            0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ])
        let expected = INI1Header(magic: 0x31494E49, size: 819200, numProcesses: 2, reserved: 0)
        
        // --- ACT ---
        let parsed = try INI1Header.parse(from: mockData.withUnsafeBytes { $0 })
        
        // --- ASSERT ---
        #expect(parsed == expected)
    }
}

// MARK: - 4. KIP1Header
@Suite("KIP1Header Parsing Tests")
struct KIP1HeaderTests {
    // CORRECTED: Generic constraint added to helper function.
    func write<T: FixedWidthInteger>(_ value: T, to buffer: inout Data, at offset: Int) {
        buffer.withUnsafeMutableBytes {
            $0.baseAddress!.advanced(by: offset).storeBytes(of: value.littleEndian, as: T.self)
        }
    }

    @Test("Should correctly parse a valid KIP1 header")
    func testKIP1HeaderParsing() throws {
        // --- ARRANGE ---
        var mockBuffer = Data(count: KIP1Header.fixedSize)
        write(0x3150494B as UInt32, to: &mockBuffer, at: 0)
        let name = "loader".data(using: .ascii)!
        mockBuffer.replaceSubrange(4..<4+name.count, with: name)
        write(0x0100000000000005 as UInt64, to: &mockBuffer, at: 16)
        write(1 as UInt32, to: &mockBuffer, at: 24)
        write(240 as UInt8, to: &mockBuffer, at: 28)
        write(254 as UInt8, to: &mockBuffer, at: 29)
        write(8 as UInt8, to: &mockBuffer, at: 31)
        write(0x1000 as UInt32, to: &mockBuffer, at: 32)
        write(0x2000 as UInt32, to: &mockBuffer, at: 36)
        write(0x3000 as UInt32, to: &mockBuffer, at: 40)
        write(1 as UInt32, to: &mockBuffer, at: 44)
        
        let expected = KIP1Header(magic: 0x3150494B, name: "loader", titleId: 0x0100000000000005, processCategory: 1, mainThreadPriority: 240, defaultCore: 254, reserved0x1E: 0, flags: 8, sectionHeaders: [.init(memoryOffset: 0x1000, size: 0x2000, fileOffset: 0x3000, attribute: 1)] + Array(repeating: .init(memoryOffset: 0, size: 0, fileOffset: 0, attribute: 0), count: 5), capabilities: Array(repeating: 0, count: 32))
        
        // --- ACT ---
        let parsed = try KIP1Header.parse(from: mockBuffer.withUnsafeBytes { $0 })
        
        // --- ASSERT ---
        #expect(parsed == expected)
    }
}

// MARK: - 5. NPDMHeader
@Suite("NPDMHeader Parsing Tests")
struct NPDMHeaderTests {
    @Test("Should correctly parse a valid NPDM header")
    func testNPDMHeaderParsing() throws {
        // --- ARRANGE ---
        var mockBuffer = Data(count: NPDMHeader.size)
        mockBuffer.withUnsafeMutableBytes {
            $0.baseAddress!.storeBytes(of: (0x4154454D as UInt32).littleEndian, as: UInt32.self)
            $0.baseAddress!.advanced(by: 112).storeBytes(of: (128 as UInt32).littleEndian, as: UInt32.self)
            $0.baseAddress!.advanced(by: 116).storeBytes(of: (2048 as UInt32).littleEndian, as: UInt32.self)
            $0.baseAddress!.advanced(by: 120).storeBytes(of: (2176 as UInt32).littleEndian, as: UInt32.self)
            $0.baseAddress!.advanced(by: 124).storeBytes(of: (512 as UInt32).littleEndian, as: UInt32.self)
        }
        
        let expected = NPDMHeader(magic: 0x4154454D, acidSignKeyIndex: 0, reserved0x8: 0, mmuFlags: 0, reserved0xD: 0, mainThreadPrio: 0, defaultCpuid: 0, reserved0x10: 0, version: 0, mainStackSize: 0, titleName: "", aci0Offset: 128, aci0Size: 2048, acidOffset: 2176, acidSize: 512)
        
        // --- ACT ---
        let parsed = try NPDMHeader.parse(from: mockBuffer.withUnsafeBytes { $0 })
        
        // --- ASSERT ---
        #expect(parsed == expected)
    }
}


// MARK: - 7. NCAHeader & 8. NCAFileSystemHeader
@Suite("NCAHeader & NCAFileSystemHeader Parsing Tests")
struct NCAHeaderTests {
    func write<T: FixedWidthInteger>(_ value: T, to buffer: inout Data, at offset: Int) {
        buffer.withUnsafeMutableBytes {
            $0.baseAddress!.advanced(by: offset).storeBytes(of: value.littleEndian, as: T.self)
        }
    }

    @Test("Should correctly parse a valid NCA header")
    func testNCAHeaderParsing() throws {
        // --- ARRANGE ---
        let mockData = Data([
            0x43, 0xC4, 0x8C, 0x36, 0x58, 0x30, 0xDB, 0x78, 0x98, 0x74, 0x3E, 0xDE, 0x9E, 0xD9, 0xCF, 0x98,
            0xB1, 0x86, 0x63, 0x94, 0x22, 0xB5, 0x9F, 0xE8, 0x69, 0xB7, 0xA7, 0xF7, 0xA4, 0x48, 0x28, 0xD3,
            0x4E, 0x9A, 0xCE, 0xFE, 0x28, 0x26, 0x0A, 0x15, 0x59, 0x1E, 0x9B, 0xC2, 0xF1, 0x10, 0x32, 0xB1,
            0x7F, 0xD6, 0x4B, 0x52, 0x2C, 0x75, 0xC1, 0xF0, 0x55, 0xCB, 0xDC, 0xE9, 0x0C, 0x04, 0xC5, 0xE5,
            0xC9, 0x80, 0x9D, 0xEB, 0x72, 0xA9, 0x58, 0x6E, 0x5B, 0x22, 0x44, 0xFE, 0x6E, 0x3B, 0xB7, 0x94,
            0x15, 0xC6, 0xE7, 0x29, 0xCD, 0xE4, 0x97, 0x16, 0x37, 0xE3, 0x21, 0xF4, 0xD3, 0xCC, 0x2A, 0xA8,
            0x85, 0x1A, 0xB3, 0x60, 0x36, 0xBE, 0x6B, 0x26, 0x35, 0x80, 0x20, 0x1E, 0x76, 0x0C, 0x1E, 0xCB,
            0x01, 0x0C, 0xAE, 0xD1, 0x75, 0xBA, 0xD1, 0xC8, 0xDA, 0x89, 0xE9, 0x4F, 0x56, 0x8F, 0x6B, 0x43,
            0x85, 0xF7, 0x97, 0xBB, 0xA4, 0x40, 0x98, 0x95, 0x1B, 0x3B, 0xAB, 0xAB, 0xC0, 0xE3, 0x56, 0x21,
            0xEF, 0x26, 0xAA, 0xCB, 0x49, 0xA2, 0xC5, 0x8E, 0xA9, 0xE6, 0x37, 0xD2, 0x39, 0x1E, 0x27, 0x34,
            0xF2, 0xE9, 0x5C, 0x7C, 0x76, 0xA5, 0xC1, 0xC9, 0xB6, 0x84, 0xDF, 0xF5, 0x99, 0x5B, 0x79, 0x77,
            0x3C, 0x20, 0x8E, 0x23, 0x29, 0xDA, 0xF1, 0xDB, 0x73, 0x82, 0xE1, 0xDA, 0x98, 0xA6, 0xBC, 0x75,
            0x78, 0x58, 0x7B, 0xCA, 0xCE, 0x13, 0xE4, 0x57, 0xC4, 0xC0, 0xC2, 0xBE, 0x07, 0x19, 0x19, 0xCF,
            0x78, 0x69, 0x1A, 0xE1, 0xA9, 0xBD, 0x00, 0x87, 0xAA, 0x44, 0xE1, 0xD8, 0x68, 0x83, 0xC7, 0xED,
            0x0C, 0xE0, 0x9A, 0x12, 0xE1, 0x6D, 0xC6, 0xE6, 0xE3, 0xDE, 0x21, 0xCF, 0x9F, 0x05, 0xE9, 0x9D,
            0x2A, 0x9C, 0xA2, 0x45, 0x4F, 0xC6, 0xE8, 0xEE, 0x59, 0x48, 0x56, 0xFC, 0x1C, 0x24, 0x86, 0xE1,
            0x54, 0x71, 0x61, 0xBA, 0xF4, 0x01, 0x0C, 0x47, 0xD6, 0x2B, 0x7E, 0xF4, 0xD6, 0x1C, 0x5C, 0xD4,
            0xC0, 0xFC, 0x44, 0x97, 0xA5, 0xA5, 0x54, 0xAC, 0x5D, 0x38, 0x33, 0xD5, 0xAD, 0xC7, 0x86, 0x87,
            0xD4, 0xE8, 0xC8, 0x33, 0x46, 0xCA, 0x39, 0x50, 0xF4, 0x6D, 0x5D, 0x17, 0x25, 0x00, 0xCA, 0x0D,
            0xED, 0xA9, 0x1B, 0x93, 0xAC, 0x23, 0x8D, 0x17, 0x50, 0x1C, 0x87, 0x2E, 0xE0, 0x8C, 0xAF, 0xB0,
            0xDF, 0x03, 0xE5, 0xBA, 0xFE, 0x07, 0x55, 0x90, 0x13, 0xE4, 0xF4, 0x91, 0xBC, 0x41, 0x79, 0xD4,
            0x32, 0x03, 0x4B, 0x0F, 0x85, 0xC2, 0xF5, 0x02, 0x54, 0x9B, 0x60, 0x8A, 0x94, 0x76, 0xF1, 0x32,
            0x10, 0x61, 0x6D, 0x83, 0x00, 0x5C, 0xED, 0x8E, 0x14, 0xA8, 0x76, 0xA3, 0x2D, 0x79, 0x85, 0x05,
            0x8A, 0x9A, 0x48, 0x8C, 0x05, 0x82, 0x6E, 0x8E, 0xD2, 0x26, 0xE8, 0xF4, 0x8F, 0xD8, 0x17, 0x5F,
            0x6F, 0xF8, 0x9A, 0x6B, 0xB2, 0x01, 0x12, 0x44, 0xEF, 0xDA, 0x4C, 0x4B, 0xE7, 0x4D, 0xAD, 0xE4,
            0xF6, 0x26, 0x60, 0x41, 0x34, 0x4B, 0x6D, 0x72, 0x89, 0x47, 0x55, 0x93, 0x9E, 0xD5, 0xD5, 0xE4,
            0x28, 0xD7, 0xCA, 0x05, 0x46, 0xE8, 0x67, 0xFC, 0x52, 0x33, 0x9B, 0x8E, 0x94, 0x83, 0xFE, 0x2E,
            0xA3, 0xCB, 0xE9, 0x42, 0xC4, 0x1C, 0x09, 0x3D, 0x19, 0x2D, 0x3F, 0x3D, 0xFF, 0x8D, 0x6B, 0xBA,
            0x7F, 0xDF, 0x48, 0x4A, 0xC4, 0xF3, 0x68, 0x26, 0xEF, 0x1F, 0xD1, 0xCE, 0x5E, 0x62, 0xAF, 0xF6,
            0x23, 0xEE, 0x7F, 0xFE, 0xB9, 0xE3, 0x01, 0x05, 0x16, 0x71, 0x89, 0xC3, 0xF1, 0xCF, 0x12, 0xCB,
            0xF8, 0xD4, 0x28, 0x58, 0xF5, 0x02, 0xA5, 0xEA, 0x38, 0x54, 0xF2, 0x35, 0xAA, 0xB5, 0x74, 0x30,
            0x2B, 0xEC, 0x2A, 0x8B, 0x1A, 0x09, 0x4C, 0x9B, 0x7E, 0x9D, 0xB8, 0xDB, 0xB6, 0x77, 0xBF, 0x10,
            0x4E, 0x43, 0x41, 0x33, 0x00, 0x00, 0x02, 0x00, 0x00, 0xC0, 0x74, 0x2E, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x40, 0x06, 0x07, 0x90, 0x8E, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x03,
            0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x8E, 0x90, 0x07, 0x06, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
            0xA0, 0x75, 0x16, 0x00, 0x60, 0x3A, 0x17, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xE0, 0x00, 0x00, 0x00, 0xA0, 0x75, 0x16, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x20, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x03, 0xE0, 0x40, 0x84, 0xDD, 0x77, 0x88, 0xD7, 0x6F, 0x96, 0x3C, 0xD3, 0xE6, 0xEC, 0xB3, 0x0F,
            0x8F, 0xEC, 0x7A, 0x67, 0x2A, 0x59, 0x3A, 0xF4, 0xF6, 0xEB, 0x72, 0x95, 0x25, 0x22, 0x32, 0xFD,
            0xEE, 0xAE, 0x16, 0x83, 0xDD, 0xC1, 0x40, 0xED, 0xE1, 0xA3, 0x71, 0xB7, 0x71, 0x5F, 0x4E, 0x36,
            0x92, 0x0B, 0xA2, 0x16, 0x26, 0x21, 0xFE, 0xFF, 0x60, 0xF5, 0xA8, 0x3C, 0x72, 0x46, 0x85, 0x2A,
            0x3B, 0x2A, 0xF0, 0xDE, 0x5C, 0xC8, 0x28, 0xAF, 0x5E, 0xAD, 0x31, 0x0F, 0x9C, 0x09, 0x8B, 0xB8,
            0xFA, 0x60, 0x02, 0x8D, 0x0D, 0x42, 0x03, 0x0E, 0xF0, 0x82, 0x73, 0x2D, 0x45, 0x6B, 0xE4, 0x84,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x02, 0x00, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0xD4, 0x9A, 0xDC, 0x30, 0x64, 0x9E, 0x10, 0x6A,
            0xF4, 0x21, 0x90, 0xCC, 0x52, 0x70, 0xFF, 0xB6, 0x9B, 0xB0, 0xFD, 0x4C, 0x43, 0x04, 0x15, 0x0E,
            0x16, 0x31, 0x95, 0x51, 0x1B, 0x40, 0x13, 0xC0, 0x00, 0x80, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0xD5, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x49, 0x56, 0x46, 0x43, 0x00, 0x00, 0x02, 0x00,
            0x20, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x80, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x80, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xC6, 0xD1, 0x2C, 0x00, 0x00, 0x00, 0x00,
            0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xB4, 0x73, 0x3D, 0x07, 0x2D, 0xC8, 0xCB,
            0x66, 0x19, 0x0B, 0x9D, 0xC0, 0x8B, 0x2D, 0x9A, 0x7F, 0xB3, 0xDF, 0xBA, 0x50, 0xE8, 0xD3, 0x10,
            0xFE, 0x44, 0x51, 0xE1, 0x8D, 0x37, 0xFD, 0x96, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x02, 0x00, 0x01, 0x02, 0x01, 0x00, 0x00, 0x00, 0x5D, 0x02, 0xE6, 0xBB, 0xD3, 0x46, 0xB5, 0xFC,
            0xD4, 0x30, 0x07, 0x63, 0xAF, 0x23, 0xCC, 0x1C, 0x1C, 0xE2, 0xC9, 0x4A, 0xD7, 0xED, 0xF8, 0xD5,
            0x2C, 0x75, 0x61, 0x50, 0x83, 0x01, 0x77, 0x55, 0x00, 0x10, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD4, 0x17, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ])
        // --- END SWIFT MOCK DATA ---
        struct MockSectionInfo {
            let startOffset: UInt32
            let endOffset: UInt32
            let fsType: UInt8
            let cryptoType: UInt8
        }
        
        let mockSections: [MockSectionInfo] = [
            MockSectionInfo(startOffset: 0x1675A0, endOffset: 0x173A60, fsType: 2, cryptoType: 3),
            MockSectionInfo(startOffset: 0xE0, endOffset: 0x1675A0, fsType: 3, cryptoType: 3),
            MockSectionInfo(startOffset: 0x20, endOffset: 0xE0, fsType: 2, cryptoType: 1),
            MockSectionInfo(startOffset: 0x0, endOffset: 0x0, fsType: 0, cryptoType: 0)
        ]
        
        let expectedHeader = NCAHeader(fixedKeySig: Data(count: 256), npdmKeySig: Data(count: 256), magic: 859915086, distribution: 0, contentType: .program, cryptoType: .ctr, kaekInd: 0, ncaSize: 779403264, titleId: 72214343282212864, sdkVersion: .init(rawValue: 50593792), cryptoType2: 4, fixedKeyGeneration: 0, rightsId: Data(), sectionEntries: [
            .init(mediaOffset: 1471904, mediaEndOffset: 1522272, reserved: 1),
            .init(mediaOffset: 224, mediaEndOffset: 1471904, reserved: 1),
            .init(mediaOffset: 32, mediaEndOffset: 224, reserved: 1),
            .init(mediaOffset: 0, mediaEndOffset: 0, reserved: 0)], sectionHashes: Array(repeating: Data(count: 32), count: 4), encryptedKeys: Array(repeating: Data(count: 16), count: 4), fsHeaders: [
                NCAFileSystemHeader(partitionType: 1, fsType: .pfs0, cryptType: .ctr, superblock: Data(count: 312), sectionCtr: 4294967296),
                NCAFileSystemHeader(partitionType: 0, fsType: .pfs0, cryptType: .ctr, superblock: Data(count: 312), sectionCtr: 8589934592),
                NCAFileSystemHeader(partitionType: 0, fsType: .romfs, cryptType: .ctr, superblock: Data(count: 312), sectionCtr: 0),
                NCAFileSystemHeader(partitionType: 1, fsType:  nil, cryptType: nil, superblock: Data(count: 312), sectionCtr: 0),
            ])
        
        // --- ACT ---
        let parsed = try NCAHeader.parse(from: mockData.withUnsafeBytes { $0 })
        print(parsed.toPrettyString(indent: "  "))
        // --- ASSERT ---
        // CORRECTED: Typos fixed.
        #expect(parsed == expectedHeader)
    }
}

// MARK: - 10. NCA0RomFSHeader
@Suite("NCA0RomFSHeader Parsing Tests")
struct NCA0RomFSHeaderTests {
    @Test("Should correctly parse a valid NCA0 RomFS header")
    func testNCA0RomFSHeaderParsing() throws {
        // --- ARRANGE ---
        let mockData = Data([0x28,0x00,0x00,0x00,0x28,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x58,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0xA0,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0xC0,0x00,0x00,0x00])
        let expected = NCA0RomFSHeader(headerSize: 40, dirHashTableOffset: 40, dirHashTableSize: 48, dirMetaTableOffset: 88, dirMetaTableSize: 24, fileHashTableOffset: 112, fileHashTableSize: 48, fileMetaTableOffset: 160, fileMetaTableSize: 32, dataOffset: 192)
        
        // --- ACT ---
        let parsed = try NCA0RomFSHeader.parse(from: mockData.withUnsafeBytes { $0 })
        
        // --- ASSERT ---
        #expect(parsed == expected)
    }
}

// MARK: - 11. NSO0Header
@Suite("NSO0Header Parsing Tests")
struct NSO0HeaderTests {
    func write<T: FixedWidthInteger>(_ value: T, to buffer: inout Data, at offset: Int) {
        buffer.withUnsafeMutableBytes {
            $0.baseAddress!.advanced(by: offset).storeBytes(of: value.littleEndian, as: T.self)
        }
    }
    @Test("Should correctly parse a valid NSO0 header")
    func testNSO0HeaderParsing() throws {
        // --- ARRANGE ---
        var mockBuffer = Data(count: NSO0Header.fixedSize)
        write(0x304F534E as UInt32, to: &mockBuffer, at: 0x00)
        write(0b0111 as UInt32, to: &mockBuffer, at: 0x0C)
        write(0x100 as UInt32, to: &mockBuffer, at: 0x10)
        write(0x8004000 as UInt32, to: &mockBuffer, at: 0x14)
        write(0x12000 as UInt32, to: &mockBuffer, at: 0x18)
        write(0x8000 as UInt32, to: &mockBuffer, at: 0x60)
        write(0xABCDEF as UInt64, to: &mockBuffer, at: 0x90)
        write(0xFEDCBA as UInt64, to: &mockBuffer, at: 0x98)
        
        let expected = NSO0Header(magic: 0x304F534E, flags: 0b0111, segments: [.init(fileOffset: 0x100, memoryOffset: 0x8004000, size: 0x12000, reserved: 0), .init(fileOffset: 0, memoryOffset: 0, size: 0, reserved: 0), .init(fileOffset: 0, memoryOffset: 0, size: 0, reserved: 0)], buildId: Data(count: 32), compressedSizes: [0x8000, 0, 0], dynstrExtents: 0xABCDEF, dynsymExtents: 0xFEDCBA, sectionHashes: Array(repeating: Data(count: 32), count: 3))
        
        // --- ACT ---
        let parsed = try NSO0Header.parse(from: mockBuffer.withUnsafeBytes { $0 })
        
        // --- ASSERT ---
        #expect(parsed == expected)
    }
}

// MARK: - 12. PK11MarikoOEMHeader
@Suite("PK11MarikoOEMHeader Parsing Tests")
struct PK11MarikoOEMHeaderTests {
    func write<T: FixedWidthInteger>(_ value: T, to buffer: inout Data, at offset: Int) {
        buffer.withUnsafeMutableBytes {
            $0.baseAddress!.advanced(by: offset).storeBytes(of: value.littleEndian, as: T.self)
        }
    }
    @Test("Should correctly parse a valid PK11 Mariko OEM header")
    func testPK11MarikoOEMHeaderParsing() throws {
        // --- ARRANGE ---
        var mockBuffer = Data(count: PK11MarikoOEMHeader.size)
        write(0x1000 as UInt32, to: &mockBuffer, at: 336)
        write(0x2000 as UInt32, to: &mockBuffer, at: 340)
        write(0x3000 as UInt32, to: &mockBuffer, at: 344)
        write(0x4000 as UInt32, to: &mockBuffer, at: 348)
        
        let expected = PK11MarikoOEMHeader(aesMac: Data(count: 16), rsaSig: Data(count: 256), salt: Data(count: 32), hash: Data(count: 32), blVersion: 0x1000, blSize: 0x2000, blLoadAddr: 0x3000, blEntrypoint: 0x4000)
        
        // --- ACT ---
        let parsed = try PK11MarikoOEMHeader.parse(from: mockBuffer.withUnsafeBytes { $0 })
        
        // --- ASSERT ---
        #expect(parsed == expected)
    }
}

// MARK: - 13. PK11Metadata
@Suite("PK11Metadata Parsing Tests")
struct PK11MetadataTests {
    func write<T: FixedWidthInteger>(_ value: T, to buffer: inout Data, at offset: Int) {
        buffer.withUnsafeMutableBytes {
            $0.baseAddress!.advanced(by: offset).storeBytes(of: value.littleEndian, as: T.self)
        }
    }
    @Test("Should correctly parse valid PK11 metadata")
    func testPK11MetadataParsing() throws {
        // --- ARRANGE ---
        var mockBuffer = Data(count: PK11Metadata.size)
        write(0xAAAAAAAA as UInt32, to: &mockBuffer, at: 0)
        write(0xBBBBBBBB as UInt32, to: &mockBuffer, at: 4)
        write(0xCCCCCCCC as UInt32, to: &mockBuffer, at: 8)
        
        let date = "20240101".data(using: .ascii)!
        // CORRECTED: API usage fixed.
        mockBuffer.withUnsafeMutableBytes {
            $0.baseAddress!.advanced(by: 16).copyMemory(from: (date as NSData).bytes, byteCount: date.count)
        }
        write(7 as UInt8, to: &mockBuffer, at: 31)
        
        let expected = PK11Metadata(ldrHash: 0xAAAAAAAA, smHash: 0xBBBBBBBB, blHash: 0xCCCCCCCC, reserved: 0, buildDate: "20240101", version: 7)
        
        // --- ACT ---
        let parsed = try PK11Metadata.parse(from: mockBuffer.withUnsafeBytes { $0 })
        
        // --- ASSERT ---
        #expect(parsed == expected)
    }
}

// MARK: - 16. PK11PayloadHeader
@Suite("PK11PayloadHeader Parsing Tests")
struct PK11PayloadHeaderTests {
    @Test("Should correctly parse a valid PK11 payload header")
    func testPK11PayloadParsing() throws {
        // --- ARRANGE ---
        let mockData = Data([0x50,0x4B,0x31,0x31,0xA0,0x6E,0x00,0x00,0x40,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x02,0x00,0x80,0x00,0x10,0x00,0x00,0x1C,0x00,0x00,0x00,0x00,0x04,0x40])
        let expected = PK11PayloadHeader(magic: 0x31314B50, wbSize: 28320, wbEp: 1048640, reserved: 0, blSize: 137216, blEp: 1048704, smSize: 7168, smEp: 1073741824)
        
        // --- ACT ---
        let parsed = try PK11PayloadHeader.parse(from: mockData.withUnsafeBytes { $0 })
        
        // --- ASSERT ---
        #expect(parsed == expected)
    }
}

// MARK: - 17. PK21Header
@Suite("PK21Header Parsing Tests")
struct PK21HeaderTests {
    func write<T: FixedWidthInteger>(_ value: T, to buffer: inout Data, at offset: Int) {
        buffer.withUnsafeMutableBytes {
            $0.baseAddress!.advanced(by: offset).storeBytes(of: value.littleEndian, as: T.self)
        }
    }
    @Test("Should correctly parse a valid PK21 header")
    func testPK21HeaderParsing() throws {
        // --- ARRANGE ---
        var mockBuffer = Data(count: PK21Header.size)
        write(0x31324B50 as UInt32, to: &mockBuffer, at: 0x150)
        write(0x4000 as UInt32, to: &mockBuffer, at: 0x154)
        write(10 as UInt8, to: &mockBuffer, at: 0x15C)
        write(8 as UInt8, to: &mockBuffer, at: 0x15D)
        write(0x100 as UInt32, to: &mockBuffer, at: 0x160)
        write(0x200 as UInt32, to: &mockBuffer, at: 0x170)
        
        let expected = PK21Header(signature: Data(count: 256), ctr: Data(count: 16), sectionCtrs: Array(repeating: Data(count: 16), count: 4), magic: 0x31324B50, baseOffset: 0x4000, reserved: 0, versionMax: 10, versionMin: 8, sectionSizes: [0x100, 0, 0, 0], sectionOffsets: [0x200, 0, 0, 0], sectionHashes: Array(repeating: Data(count: 32), count: 4))
        
        // --- ACT ---
        let parsed = try PK21Header.parse(from: mockBuffer.withUnsafeBytes { $0 })
        
        // --- ASSERT ---
        #expect(parsed == expected)
    }
}

// MARK: - 18. RomFSHeader
@Suite("RomFSHeader Parsing Tests")
struct RomFSHeaderTests {
    @Test("Should correctly parse a valid RomFS header")
    func testRomFSHeaderParsing() throws {
        // --- ARRANGE ---
        let mockData = Data([0x50,0,0,0,0,0,0,0,0x50,0,0,0,0,0,0,0,0x10,0,0,0,0,0,0,0,0x60,0,0,0,0,0,0,0,0x18,0,0,0,0,0,0,0,0x78,0,0,0,0,0,0,0,0x10,0,0,0,0,0,0,0,0x88,0,0,0,0,0,0,0,0x20,0,0,0,0,0,0,0,0xA8,0,0,0,0,0,0,0])
        let expected = RomFSHeader(headerSize: 80, dirHashTableOffset: 80, dirHashTableSize: 16, dirMetaTableOffset: 96, dirMetaTableSize: 24, fileHashTableOffset: 120, fileHashTableSize: 16, fileMetaTableOffset: 136, fileMetaTableSize: 32, dataOffset: 168)
        
        // --- ACT ---
        let parsed = try RomFSHeader.parse(from: mockData.withUnsafeBytes { $0 })
        
        // --- ASSERT ---
        #expect(parsed == expected)
    }
}

// MARK: - 19. SaveHeader
@Suite("SaveHeader Parsing Tests")
struct SaveHeaderTests {
    @Test("Should correctly parse the beginning of a Save header")
    func testSaveHeaderParsing() throws {
        // --- ARRANGE ---
        var mockBuffer = Data(count: SaveHeader.size)
        let cmac = "THISISATESTCMAC!".data(using: .ascii)!
        let layoutData = "LAYOUTDATA".data(using: .ascii)!
        
        mockBuffer.withUnsafeMutableBytes {
            let ptr = $0.baseAddress!
            ptr.copyMemory(from: (cmac as NSData).bytes, byteCount: 16)
            ptr.advanced(by: 0x100).copyMemory(from: (layoutData as NSData).bytes, byteCount: layoutData.count)
        }
        
        var expectedLayout = Data(count: 512)
        expectedLayout.replaceSubrange(0..<layoutData.count, with: layoutData)
        
        let expected = SaveHeader(cmac: cmac, layout: expectedLayout)

        // --- ACT ---
        let parsed = try SaveHeader.parse(from: mockBuffer.withUnsafeBytes { $0 })

        // --- ASSERT ---
        #expect(parsed == expected)
    }
}

// MARK: - 20. RemapEntry
@Suite("RemapEntry Parsing Tests")
struct RemapEntryTests {
    @Test("Should correctly parse a valid RemapEntry")
    func testRemapEntryParsing() throws {
        // --- ARRANGE ---
        let mockData = Data([0x00,0x10,0,0,0,0,0,0,0x00,0x20,0,0,0,0,0,0,0x00,0x10,0,0,0,0,0,0,0x00,0x10,0,0,0xFF,0xFF,0xFF,0xFF])
        let expected = RemapEntry(virtualOffset: 4096, physicalOffset: 8192, size: 4096, alignment: 4096, reserved: 0xFFFFFFFF)
        
        // --- ACT ---
        let parsed = try RemapEntry.parse(from: mockData.withUnsafeBytes { $0 })
        
        // --- ASSERT ---
        #expect(parsed == expected)
    }
}

// MARK: - 21. XCIHeader
@Suite("XCIHeader Parsing Tests")
struct XCIHeaderTests {
    @Test("Should correctly parse a valid XCI header")
    func testXCIHeaderParsing() throws {
        // --- ARRANGE ---
        var mockBuffer = Data(count: XCIHeader.size)
        mockBuffer.withUnsafeMutableBytes {
            var ptr = $0.baseAddress! + 0x100
            ptr.storeBytes(of: (0x44414548 as UInt32).littleEndian, as: UInt32.self); ptr += 4
            ptr.storeBytes(of: (0x7E00 as UInt32).littleEndian, as: UInt32.self); ptr += 8
            ptr.storeBytes(of: 0xF8 as UInt8, as: UInt8.self); ptr += 7
            ptr.storeBytes(of: (0x3FFFFF as UInt64).littleEndian, as: UInt64.self); ptr += 8
            
            ptr = $0.baseAddress! + 0x130
            ptr.storeBytes(of: (0x7E00 as UInt64).littleEndian, as: UInt64.self); ptr += 8
            ptr.storeBytes(of: (0x200 as UInt64).littleEndian, as: UInt64.self)
        }

        let expected = XCIHeader(headerSig: Data(count: 256), magic: 0x44414548, secureOffset: 0x7E00, cartType: 0xF8, cartSizeRaw: 0x3FFFFF, reversedIV: Data(count: 16), hfs0Offset: 0x7E00, hfs0HeaderSize: 0x200, hfs0HeaderHash: Data(count: 32), cryptoHeaderHash: Data(count: 32), encryptedData: Data(count: 112))

        // --- ACT ---
        let parsed = try XCIHeader.parse(from: mockBuffer.withUnsafeBytes { $0 })

        // --- ASSERT ---
        #expect(parsed == expected)
    }
}
